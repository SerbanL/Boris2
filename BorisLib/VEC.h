#pragma once

#include <omp.h>
#include <tuple>

#include "BLib_Types.h"
#include "Funcs_Aux_base.h"
#include "Funcs_Math.h"
#include "Funcs_Vectors.h"
#include "BLib_prng.h"
#include "BLib_OmpReduction.h"

#include "VEC_shapedef.h"

////////////////////////////////////////////////////////////////////////////////////////////////// VEC<VType>
//
// n-component quantity with 3 dimensions

template <typename VType> class Transfer;

template <typename VType> 
class VEC {

	friend Transfer<VType>;

private:

	//Line profile extraction data

	//temporary storage for extracting line profile data : the extracted mesh points only as VType
	std::vector<VType> line_profile_storage;

	//extract a single component, for VAL3 floating types, together with line profile displacement as xy data.
	std::vector<DBL2> line_profile_component;

	//Histogram extraction data

	std::vector<std::vector<double>> histogram;

protected:

	//used for min, max and average reduction : stuck with OMP2.0 currently!
	mutable OmpReduction<VType> reduction;

	//used for reductions by magnitude : i.e. for a value of VType reduce (e.g. maximum) for GetMagnitude(value)
	mutable OmpReduction<decltype(GetMagnitude(std::declval<VType>()))> magnitude_reduction, magnitude_reduction2;

	//the actual mesh quantity
	std::vector<VType> quantity;

	//mesh transfer object : handled using the MESH TRANSFER methods below. Not saved by ProgramState, so needs to be remade if reloading this VEC.
	//Defined in VEC_MeshTransfer.h
	Transfer<VType> transfer;

public:

	//dimensions along x, y and z of the quantity
	SZ3 n = SZ3(0);

	//cellsize of structured mesh
	DBL3 h = DBL3(0);

	//rectangle, same units as h. VEC has n number of cells, so n * h gives the rect dimensions. All that is really needed is the rect start coordinates
	Rect rect = Rect();

private:

	//--------------------------------------------HELPER METHODS : VEC_mng.h

	void SetMeshRect(void) { rect.e = rect.s + (h & n); }

	//set new size and map mesh values to new dimension, keeping magnitude (so don't use an average). Return outcome; if failed then no changes made.
	bool mapmesh_newdims(const SZ3& new_n);

	//from current rectangle and h value set n. h may also need to be adjusted since n must be an integer. Resize quantity to new n value : return success or fail. If failed then nothing changed.
	bool set_n_adjust_h(void);

	//---------------------------------------------MULTIPLE ENTRIES SETTERS - VEC SHAPE MASKS : VEC_shapemask.h

	//auxiliary function for generating shapes, where the shape is defined in shape_method
	//shape_method takes two parameters: distance from shape centre and dimensions of shape; if point is within shape then return true
	//generate shape at centre_pos with given rotation
	//make given number of repetitions, with displacements between repetitions
	//shape set using the indicated method (or, not, xor) and default_value
	void shape_setter(std::function<bool(DBL3, DBL3)>& shape_method, MeshShape shape, VType default_value);

	//set composite shape: differs slightly from single elementary shape setter: this adds the composite shape into the mesh, so any subtractive shapes are only subtracted when forming the composite shape, not subtracted from the mesh
	void shape_setter(std::vector<std::function<bool(DBL3, DBL3)>> shape_methods, std::vector<MeshShape> shapes, VType default_value);

	//similar to shape_setter, but sets value in composite shape composite shape is not empty
	void shape_valuesetter(std::vector<std::function<bool(DBL3, DBL3)>> shape_methods, std::vector<MeshShape> shapes, VType value);

	//get average value from composite shape
	VType shape_valuegetter(std::vector<std::function<bool(DBL3, DBL3)>> shape_methods, std::vector<MeshShape> shapes);

protected:

	//from h_ and rect_ calculate what n value results - but do not make any changes
	SZ3 get_n_from_h_and_rect(const DBL3& h_, const Rect& rect_) const;

	//generic Voronoi diagram generators - need average spacing for cell sites, which are generated using a random number generator (prng). Cells will take on a value generated by the value_generator function.

	//2D
	void GenerateVoronoi2D(double spacing, BorisRand& prng, std::function<VType(void)>& value_generator);
	
	//3D
	void GenerateVoronoi3D(double spacing, BorisRand& prng, std::function<VType(void)>& value_generator);

	//2D with values generated just for the boundaries, with all other cells taking on the base value
	void GenerateVoronoiBoundary2D(double spacing, VType base_value, BorisRand& prng, std::function<VType(void)>& value_generator);

	//3D with values generated just for the boundaries, with all other cells taking on the base value
	void GenerateVoronoiBoundary3D(double spacing, VType base_value, BorisRand& prng, std::function<VType(void)>& value_generator);

public:

	//--------------------------------------------CONSTRUCTORS : VEC_mng.h

	VEC(void);

	VEC(const SZ3& n_);

	VEC(const DBL3& h_, const Rect& rect_);

	VEC(const DBL3& h_, const Rect& rect_, VType value);

	virtual ~VEC() {}

	//--------------------------------------------INDEXING

	//Index using a single combined index (use e.g. when more convenient to use a single for loop to iterate over the quantity's elements)
	VType& operator[](int idx) { return quantity[idx]; }
	//const version to allow passing in a const VEC& to functions which need to read the VEC
	const VType& operator[](int idx) const { return quantity[idx]; }

	//index using a VAL3, integral type (e.g. use with nested loops)
	VType& operator[](const INT3& idx) { return quantity[idx.i + idx.j*n.x + idx.k*n.x*n.y]; }
	const VType& operator[](const INT3& idx) const { return quantity[idx.i + idx.j*n.x + idx.k*n.x*n.y]; }

	//index by position relative to VEC rect
	VType& operator[](const DBL3& rel_pos) { return quantity[int(rel_pos.x / h.x) + int(rel_pos.y / h.y) * n.x + int(rel_pos.z / h.z) * n.x * n.y]; }
	const VType& operator[](const DBL3& rel_pos) const { return quantity[int(rel_pos.x / h.x) + int(rel_pos.y / h.y) * n.x + int(rel_pos.z / h.z) * n.x * n.y]; }

	//get the managed std::vector by reference
	std::vector<VType>& get_vector(void) { return quantity; }

	//--------------------------------------------PROPERTY CHECKING : VEC_aux.h

	bool is_not_empty(int index) const { return (quantity[index] != VType()) ; }
	bool is_not_empty(const INT3& ijk) const { return (quantity[ijk.i + ijk.j*n.x + ijk.k*n.x*n.y] != VType()); }
	bool is_not_empty(const DBL3& rel_pos) const { return (quantity[int(rel_pos.x / h.x) + int(rel_pos.y / h.y) * n.x + int(rel_pos.z / h.z) * n.x * n.y] != VType()); }

	bool is_empty(int index) const { return (quantity[index] == VType()); }
	bool is_empty(const INT3& ijk) const { return (quantity[ijk.i + ijk.j*n.x + ijk.k*n.x*n.y] == VType()); }
	bool is_empty(const DBL3& rel_pos) const { return (quantity[int(rel_pos.x / h.x) + int(rel_pos.y / h.y) * n.x + int(rel_pos.z / h.z) * n.x * n.y] == VType()); }

	//check if all cells intersecting the rectangle (absolute coordinates) are empty
	bool is_empty(const Rect& rectangle) const;
	//check if all cells intersecting the rectangle (absolute coordinates) are not empty
	bool is_not_empty(const Rect& rectangle) const;

	//--------------------------------------------ITERATORS

	VType* begin(void) { return &quantity[0]; }
	VType* end(void) { return &quantity[linear_size()]; }
	VType* data(void) { return quantity.data(); }

	//--------------------------------------------SPECIAL DATA ACCESS

	std::vector<VType>& quantity_ref(void) { return quantity; }

	//--------------------------------------------SIZING : VEC_mng.h

	//all sizing methods (apart from clear) return true (success) or false (could not resize). If failed then previous settings are maintained.

	//change to new number of cells : keep h and rect.s the same but adjust rect.e. Also map values to new size.
	bool resize(const SZ3& new_n);
	//set rect and h; n is obtained from them and h also may be adjusted. Also map values to new size.
	bool resize(const DBL3& new_h, const Rect& new_rect);

	//works like resize but sets given value also
	bool assign(const SZ3& new_n, VType value);
	//works like resize but sets given value also
	bool assign(const DBL3& new_h, const Rect& new_rect, VType value);

	//set everything to zero but h - note, using shrink_to_fit to reduce capacity to zero (the std::vector clear method does not do this)
	//if you want to set the size of this VEC to zero you should use VEC::clear, not resize the size to zero. The reason for this explained below:
	//For VECs that do not go out of scope but have previously had a large size allocated we might be blocked from resizing this or another VEC for no good reason. 
	//This is because VECs are not allowed to resize beyond the available physical memory - virtual memory is useless for what VECs are intended to do.
	void clear(void);

	void shrink_to_fit(void) { quantity.shrink_to_fit(); }

	//--------------------------------------------MULTIPLE ENTRIES SETTERS : VEC_oper.h

	//set value in box
	void setbox(const Box& box, VType value = VType());

	//set value in rectangle (i.e. in cells intersecting the rectangle), where the rectangle is relative to this VEC's rectangle.
	void setrect(const Rect& rectangle, VType value = VType());

	//set value in all cells
	void set(VType value = VType());

	//re-normalize all non-zero values to have the new magnitude (multiply by new_norm and divide by current magnitude)
	template <typename PType = decltype(GetMagnitude(std::declval<VType>()))>
	void renormalize(PType new_norm);

	//copy values from copy_this but keep current dimensions - if necessary map values from copy_this to local dimensions
	//can specify destination and source rectangles in relative coordinates
	void copy_values(const VEC<VType>& copy_this, Rect dstRect = Rect(), Rect srcRect = Rect());

	//--------------------------------------------ARITHMETIC OPERATIONS ON ENTIRE VEC : VEC_arith.h

	//add values from add_this but keep current dimensions - if necessary map values from add_this to local dimensions
	void add_values(const VEC<VType>& add_this);

	//subtract values from sub_this but keep current dimensions - if necessary map values from sub_this to local dimensions
	void sub_values(const VEC<VType>& sub_this);

	void operator+=(double constant);
	void operator-=(double constant);
	void operator*=(double constant);
	void operator/=(double constant);

	//--------------------------------------------VEC GENERATORS : VEC_generate.h, VEC_Voronoi.h

	//most of these are specialised for one type (e.g. double only, or DBL3 only)

	//generate custom values from grayscale bitmap : black = 0, white = 1. Apply scaling and offset also.
	//bitmap size must match new_n.x * new_n.y
	bool generate_custom_2D(SZ3 new_n, Rect new_rect, double offset, double scale, const std::vector<unsigned char>& bitmap) { return true; }

	//similar to generate_linear except new dimensions not set
	void set_linear(DBL3 position1, VType value1, DBL3 position2, VType value2) {}

	//linear : set VEC dimensions and use interpolation to set values in this VEC based on projected distance between position1 and position2 and given fixed end values.
	bool generate_linear(DBL3 new_h, Rect new_rect, DBL3 position1, VType value1, DBL3 position2, VType value2) { return true; }

	//random: set VEC dimensions and generate random values in given range (prng instantiated with given seed)
	bool generate_random(DBL3 new_h, Rect new_rect, DBL2 range, unsigned seed);

	//defects: set VEC dimensions (force 2D in xy plane) and generate circular defects with a tanh radial profile with values in the given range, 
	//diameter range and average spacing (prng instantiated with given seed). The defect positioning is random. 
	bool generate_defects(DBL3 new_h, Rect new_rect, DBL2 range, VType base_value, DBL2 diameter_range, double spacing, unsigned seed) { return true; }

	//faults: set VEC dimensions (force 2D in xy plane) and generate line faults in the given range length, orientation length (degrees azimuthal) and average spacing (prng instantiated with given seed).
	bool generate_faults(DBL3 new_h, Rect new_rect, DBL2 range, VType base_value, DBL2 length_range, DBL2 orientation_range, double spacing, unsigned seed) { return true; }

	//jagged: set VEC dimensions (force 2D in xy plane) and generate random values in given range (prng instantiated with given seed) at a given spacing. 
	//In between these random values use bi-linear interpolation. The random values are spaced in the xy plane at equal distances along x or y using the spacing value (same units as the VEC rect)
	bool generate_jagged(DBL3 new_h, Rect new_rect, DBL2 range, double spacing, unsigned seed) { return true; }

	//absorbing boundary conditions polynomial slopes: set VEC dimensions and generate polynomial slopes at slides
	//polynomial slopes at sides with exponent n, starting from maximum value at surfaces, proceeding inwards towards minimum up to a depth of length * ratio
	//abl_x, abl_y, abl_z : depth ratio for negative side, depth ratio for positive side
	//values : minimum centre, maximum outer, polynomial exponent
	bool generate_ablpol(DBL3 new_h, Rect new_rect, DBL2 abl_x, DBL2 abl_y, DBL2 abl_z, DBL3 values) { return true; }

	//absorbing boundary conditions tanh slopes: set VEC dimensions and generate tanh slopes at slides
	//tanh slopes at sides with sigma value, starting from maximum value at surfaces, proceeding inwards towards minimum up to a depth of length * ratio
	//tanh profile centered
	//abl_x, abl_y, abl_z : depth ratio for negative side, depth ratio for positive side
	//values : minimum centre, maximum outer, tanh sigma in nm
	bool generate_abltanh(DBL3 new_h, Rect new_rect, DBL2 abl_x, DBL2 abl_y, DBL2 abl_z, DBL3 values) { return true; }

	//absorbing boundary conditions exp slopes: set VEC dimensions and generate exp slopes at slides
	//exp slopes at sides with sigma value, starting from maximum value at surfaces, proceeding inwards towards minimum up to a depth of length * ratio
	//abl_x, abl_y, abl_z : depth ratio for negative side, depth ratio for positive side
	//values : minimum centre, maximum outer, exp sigma in nm
	bool generate_ablexp(DBL3 new_h, Rect new_rect, DBL2 abl_x, DBL2 abl_y, DBL2 abl_z, DBL3 values) { return true; }

	//voronoi 2D: set VEC dimensions (force 2D in xy plane) and generate random values in the given range with each value fixed in a voronoi cell, and average spacing (prng instantiated with given seed).
	bool generate_voronoi2d(DBL3 new_h, Rect new_rect, DBL2 range, double spacing, unsigned seed);

	//voronoi 3D: set VEC dimensions and generate random values in the given range with each value fixed in a voronoi cell, and average spacing (prng instantiated with given seed).
	bool generate_voronoi3d(DBL3 new_h, Rect new_rect, DBL2 range, double spacing, unsigned seed);

	//voronoi boundary 2D: set VEC dimensions (force 2D in xy plane) and generate voronoi 2d tessellation with average spacing. Set coefficient values randomly in the given range only at the Voronoi cell boundaries (prng instantiated with given seed).
	bool generate_voronoiboundary2d(DBL3 new_h, Rect new_rect, DBL2 range, VType base_value, double spacing, unsigned seed);

	//voronoi boundary 3D: set VEC dimensions and generate voronoi 3d tessellation with average spacing. Set coefficient values randomly in the given range only at the Voronoi cell boundaries (prng instantiated with given seed).
	bool generate_voronoiboundary3d(DBL3 new_h, Rect new_rect, DBL2 range, VType base_value, double spacing, unsigned seed);

	//voronoi rotations 2D: set VEC dimensions (force 2D in xy plane) and generate voronoi 2d tessellation with average spacing. This method is applicable only to DBL3 PType, where a rotation operation is applied, fixed in each Voronoi cell. 
	//The rotation uses the values for polar (theta) and azimuthal (phi) angles specified in given ranges in degrees. prng instantiated with given seed.
	//specialised for DBL3 only : applies rotation to vector
	bool generate_voronoirotation2d(DBL3 new_h, Rect new_rect, DBL2 theta, DBL2 phi, double spacing, unsigned seed) { return true; }

	//voronoi rotations 3D: set VEC dimensions and generate voronoi 3d tessellation with average spacing. This method is applicable only to DBL3 PType, where a rotation operation is applied, fixed in each Voronoi cell. 
	//The rotation uses the values for polar (theta) and azimuthal (phi) angles specified in given ranges in degrees. prng instantiated with given seed.
	//specialised for DBL3 only : applies rotation to vector
	bool generate_voronoirotation3d(DBL3 new_h, Rect new_rect, DBL2 theta, DBL2 phi, double spacing, unsigned seed) { return true; }

	//flower state for vector type
	bool generate_flower(int direction, DBL3 centre, double radius, double thickness) { return true; }

	//onion state for vector type
	bool generate_onion(int direction, DBL3 centre, double radius1, double radius2, double thickness) { return true; }

	//cross-tie state for vector type
	bool generate_crosstie(int direction, DBL3 centre, double radius, double thickness) { return true; }

	//--------------------------------------------VEC SHAPE MASKS : VEC_shapemask.h

	//method: or (add shape) / not (delete shape) / xor (add and delete overlaps) / and (set value only if not empty)

	//all use the auxiliary shape_setter method

	//disk
	std::function<bool(DBL3, DBL3)> shape_disk(MeshShape shape, VType default_value, bool setshape = true);

	//rectangle
	std::function<bool(DBL3, DBL3)> shape_rect(MeshShape shape, VType default_value, bool setshape = true);

	//triangle
	std::function<bool(DBL3, DBL3)> shape_triangle(MeshShape shape, VType default_value, bool setshape = true);

	//ellipsoid
	std::function<bool(DBL3, DBL3)> shape_ellipsoid(MeshShape shape, VType default_value, bool setshape = true);

	//pyramid
	std::function<bool(DBL3, DBL3)> shape_pyramid(MeshShape shape, VType default_value, bool setshape = true);

	//tetrahedron
	std::function<bool(DBL3, DBL3)> shape_tetrahedron(MeshShape shape, VType default_value, bool setshape = true);

	//cone
	std::function<bool(DBL3, DBL3)> shape_cone(MeshShape shape, VType default_value, bool setshape = true);

	//torus
	std::function<bool(DBL3, DBL3)> shape_torus(MeshShape shape, VType default_value, bool setshape = true);

	//set a composite shape using combination of the above elementary shapes
	void shape_set(std::vector<MeshShape> shapes, VType default_value);

	//set a composite shape using combination of the above elementary shapes but:
	//only set value in non-empty parts of shape
	//uses the shape_valuesetter auxiliary method
	void shape_setvalue(std::vector<MeshShape> shapes, VType value);

	//--------------------------------------------GETTERS : VEC_aux.h

	SZ3 size(void) const { return n; }
	size_t linear_size(void) const { return n.dim(); }

	//from cell index return cell center coordinates (relative to start of rectangle)
	DBL3 cellidx_to_position(int idx) const { DBL3 ijk_pos = DBL3((idx % n.x) + 0.5, ((idx / n.x) % n.y) + 0.5, (idx / (n.x*n.y)) + 0.5); return (h & ijk_pos); }
	
	//from cell index return cell center coordinates (relative to start of rectangle)
	DBL3 cellidx_to_position(const INT3& ijk) const { DBL3 ijk_pos = DBL3(ijk.i + 0.5, ijk.j + 0.5, ijk.k + 0.5); return (h & ijk_pos); }

	//return cell index from relative position : the inverse of cellidx_to_position
	int position_to_cellidx(const DBL3& position) const { return floor_epsilon(position.x / h.x) + floor_epsilon(position.y / h.y) * n.x + floor_epsilon(position.z / h.z) * n.x*n.y; }

	//get index of cell which contains position (absolute value, not relative to start of rectangle), capped to mesh size
	INT3 cellidx_from_position(const DBL3& absolute_position) const;

	//get cell rectangle (absolute values, not relative to start of mesh rectangle) for cell with index ijk
	Rect get_cellrect(const INT3& ijk) const { return Rect(rect.s + (h & ijk), rect.s + (h & ijk) + h); }
	
	//get_cellrect using single index.
	Rect get_cellrect(int idx) const { INT3 ijk = INT3((idx % n.x), (idx / n.x) % n.y, idx / (n.x*n.y)); return Rect(rect.s + (h & ijk), rect.s + (h & ijk) + h); }

	//extract box of cells intersecting with the given rectangle (rectangle is in absolute coordinates). Cells in box : from and including start, up to but not including end; Limited to VEC sizes.
	Box box_from_rect_max(const Rect& rectangle) const;
	
	//extract box of cells completely included in the given rectangle (rectangle is in absolute coordinates).
	Box box_from_rect_min(const Rect& rectangle) const;

	//count cells which don't have a null value set : i.e. non-empty.
	int get_nonempty_cells(void) const;

	//--------------------------------------------EXTRACT A LINE PROFILE : VEC_extract.h

	//for all these methods use wrap-around when extracting profiles if points on profile exceed mesh boundaries

	//extract profile in profile_storage temporary vector, returned through reference: extract starting at start in the direction end - step, with given step; use average to extract profile with given stencil, excluding zero points (assumed empty)
	//all coordinates are relative positions
	std::vector<VType>& extract_profile(DBL3 start, DBL3 end, double step, DBL3 stencil);

	//as above but only component x (for VAL3 floating types only). Return xy data as line profile position and extracted component at that position.
	std::vector<DBL2>& extract_profile_component_x(DBL3 start, DBL3 end, double step, DBL3 stencil);
	//as above but only component y (for VAL3 floating types only). Return xy data as line profile position and extracted component at that position.
	std::vector<DBL2>& extract_profile_component_y(DBL3 start, DBL3 end, double step, DBL3 stencil);
	//as above but only component z (for VAL3 floating types only). Return xy data as line profile position and extracted component at that position.
	std::vector<DBL2>& extract_profile_component_z(DBL3 start, DBL3 end, double step, DBL3 stencil);
	//as above but only component which has largest value for the first point (after stencil averaging) (for VAL3 floating types only). Return xy data as line profile position and extracted component at that position.
	std::vector<DBL2>& extract_profile_component_max(DBL3 start, DBL3 end, double step, DBL3 stencil);

	//get the last calculated line profile
	std::vector<VType>& get_last_profile(void) { return line_profile_storage; }

	//--------------------------------------------HISTOGRAMS : VEC_histo.h

	//compute magnitude histogram data
	//extract histogram between magnitudes min and max with given number of bins. if min max not given (set them to zero) then determine them first.
	//if num_bins not given then use default value of 100
	//if macrocell_dims greater than 1 in any dimension then first average mesh data in macrocells of given size
	//without macrocell then pass in num_nonempty_cells (number of nonempty cells); if this is not passed it it's counted first (costs another kernel launch)
	//output transferred to cpu in histogram_cpu
	bool get_mag_histogram(
		std::vector<double>& histogram_x_cpu, std::vector<double>& histogram_p_cpu, 
		int num_bins, double& min, double& max, size_t num_nonempty_cells = 0, INT3 macrocell_dims = INT3(1));

	//get angular deviation histogram. deviation from ndir direction is calculated, or the average direction if ndir not specified (IsNull)
	bool get_ang_histogram(
		std::vector<double>& histogram_x_cpu, std::vector<double>& histogram_p_cpu,
		int num_bins, double& min, double& max, size_t num_nonempty_cells = 0, INT3 macrocell_dims = INT3(1), VType ndir = VType());

	//--------------------------------------------TRANSPOSITION : VEC_trans.h

	//transpose values from this VEC to output VEC

	//x -> y
	template <typename SType>
	void transpose_xy(VEC<SType>& out);

	//x -> z
	//transpose x and z values from this VEC to output VEC
	template <typename SType>
	void transpose_xz(VEC<SType>& out);
	
	//y -> z
	template <typename SType>
	void transpose_yz(VEC<SType>& out);

	//x, y, z -> z, x, y
	template <typename SType>
	void transpose_cycleup(VEC<SType>& out);

	//x, y, z -> y, z, x
	template <typename SType>
	void transpose_cycledn(VEC<SType>& out);

	//--------------------------------------------MATRIX OPERATIONS : VEC_matops.h

	//multiply xy planes of lvec and rvec considered as 2D matrices and place result in this VEC. Require lvec.n.x = rvec.n.y and lvec.n.z = rvec.n.z. Output matrix (this) sized as required.
	//specialised for double only
	void matrix_mul(const VEC<double>& lvec, const VEC<double>& rvec) {}

	//multiply matrix by floating point constant
	void matrix_mul(double constant);

	//multiply diagonal values in each xy plane of this VEC (considered as a matrix) by value.
	//If not square in the xy plane the "diagonal" starts at (0,0) and has min(n.x, n.y) points
	void matrix_muldiag(double value);

	//add matadd into this matrix point by point - sizes must match
	void matrix_add(const VEC<VType>& matadd);

	//add lvec and rvec (sizes must match) point by point, setting output in this matrix
	void matrix_add(const VEC<VType>& lvec, const VEC<VType>& rvec);

	//subtract matadd from this matrix point by point - sizes must match
	void matrix_sub(const VEC<VType>& matadd);

	//subtract rvec from lvec (sizes must match) point by point, setting output in this matrix
	void matrix_sub(const VEC<VType>& lvec, const VEC<VType>& rvec);

	//Invert each plane of this VEC considered as a matrix (must be square in xy plane) and return determinant of first matrix (first xy plane) - using algorithm from : A. Farooq, K. Hamid, "An Efficient and Simple Algorithm for Matrix Inversion" IJTD, 1, 20 (2010)
	//specialised for double only
	double matrix_inverse(void) { return 0.0; }

	//extract values from given xy plane (plane ranges from 0 to n.z - 1) diagonal into a std::vector
	//If not square in the xy plane the "diagonal" starts at (0,0) and has min(n.x, n.y) points
	void matrix_getdiagonal(std::vector<VType>& diagonal, int plane = 0);

	//--------------------------------------------AVERAGING OPERATIONS : VEC_avg.h

	//average in a box (which should be contained in the VEC dimensions)
	VType average(const Box& box) const;
	//average over given rectangle (relative to this VEC's rect)
	VType average(const Rect& rectangle = Rect()) const;

	//parallel processing versions - do not call from parallel code!!!
	VType average_omp(const Box& box) const;
	VType average_omp(const Rect& rectangle = Rect()) const;

	//even though VEC doesn't hold a shape we might want to obtain averages by excluding zero-value cells
	VType average_nonempty(const Box& box) const;
	VType average_nonempty(const Rect& rectangle = Rect()) const;

	//parallel processing versions - do not call from parallel code!!!
	VType average_nonempty_omp(const Box& box) const;
	VType average_nonempty_omp(const Rect& rectangle = Rect()) const;

	//smoother : obtain a weighted average value at coord, over a stencil of given size. All dimension units are same as h and rect. Include values from all cells which intersect the stencil.
	///the coord is taken as the centre value and is relative to the mesh rectangle start coordinate which might not be 0,0,0 : i.e. not an absolute value.
	//the weights vary linearly with distance from coord
	VType weighted_average(const DBL3& coord, const DBL3& stencil) const;
	
	//ijk is the cell index in a mesh with cellsize cs and same rect as this VEC; if cs is same as h then just read the value at ijk - much faster! If not then get the usual weighted average.
	VType weighted_average(const INT3& ijk, const DBL3& cs) const;

	//get average value in composite shape (defined in VEC_shapemask.h)
	VType shape_getaverage(std::vector<MeshShape> shapes);

	//--------------------------------------------NUMERICAL PROPERTIES : VEC_nprops.h

	template <typename PType = decltype(GetMagnitude(std::declval<VType>()))>
	VAL2<PType> get_minmax(const Box& box) const;
	template <typename PType = decltype(GetMagnitude(std::declval<VType>()))>
	VAL2<PType> get_minmax(const Rect& rectangle = Rect()) const;

	template <typename PType = decltype(GetMagnitude(std::declval<VType>()))>
	VAL2<PType> get_minmax_component_x(const Box& box) const;
	template <typename PType = decltype(GetMagnitude(std::declval<VType>()))>
	VAL2<PType> get_minmax_component_x(const Rect& rectangle = Rect()) const;

	template <typename PType = decltype(GetMagnitude(std::declval<VType>()))>
	VAL2<PType> get_minmax_component_y(const Box& box) const;
	template <typename PType = decltype(GetMagnitude(std::declval<VType>()))>
	VAL2<PType> get_minmax_component_y(const Rect& rectangle = Rect()) const;

	template <typename PType = decltype(GetMagnitude(std::declval<VType>()))>
	VAL2<PType> get_minmax_component_z(const Box& box) const;
	template <typename PType = decltype(GetMagnitude(std::declval<VType>()))>
	VAL2<PType> get_minmax_component_z(const Rect& rectangle = Rect()) const;

	//--------------------------------------------MESH TRANSFER : VEC_MeshTransfer.h

	//SINGLE INPUT, SINGLE OUTPUT

	//set-up mesh transfers, ready to use - return false if failed (not enough memory)
	//can set a multiplier value to apply to all contributions (1.0 by default, so no effect)
	bool Initialize_MeshTransfer(const std::vector< VEC<VType>* >& mesh_in, const std::vector< VEC<VType>* >& mesh_out, int correction_type, double multiplier = 1.0);

	//MULTIPLE INPUTS, SINGLE OUTPUT
	
	//mesh_in and mesh_in2 vectors must have same sizes
	//All VECs in mesh_in should be non-empty
	//Some VECs in mesh_in2 allowed to be non-empty (in this case single input is used), but otherwise should have exactly same dimensions as the corresponding VECs in mesh_in
	//can set a multiplier value to apply to all contributions (1.0 by default, so no effect)
	bool Initialize_MeshTransfer_AveragedInputs(const std::vector< VEC<VType>* >& mesh_in, const std::vector< VEC<VType>* >& mesh_in2, const std::vector< VEC<VType>* >& mesh_out, int correction_type, double multiplier = 1.0);

	//mesh_in2 must be a vector of VEC<double> inputs
	//can set a multiplier value to apply to all contributions (1.0 by default, so no effect)
	bool Initialize_MeshTransfer_MultipliedInputs(const std::vector< VEC<VType>* >& mesh_in, const std::vector< VEC<double>* >& mesh_in2_double, const std::vector< VEC<VType>* >& mesh_out, int correction_type, double multiplier = 1.0);

	//MULTIPLE INPUT, MULTIPLE OUTPUT

	//mesh_in and mesh_in2 vectors must have same sizes; same as mesh_out, mesh_out2
	//All VECs in mesh_in and mesh_out should be non-empty
	//Some VECs in mesh_in2 and mesh_out2 allowed to be non-empty (in this case single input/output is used), but otherwise should have exactly same dimensions as the corresponding VECs in mesh_in, mesh_out
	//Also if a VEC in mesh_in2 is non-empty the corresponding VEC in mesh_out2 should also be non-empty.
	//can set a multiplier value to apply to all contributions (1.0 by default, so no effect)
	bool Initialize_MeshTransfer_AveragedInputs_DuplicatedOutputs(const std::vector< VEC<VType>* >& mesh_in, const std::vector< VEC<VType>* >& mesh_in2, const std::vector< VEC<VType>* >& mesh_out, const std::vector< VEC<VType>* >& mesh_out2, int correction_type, double multiplier = 1.0);

	//SINGLE INPUT, SINGLE OUTPUT

	//do the actual transfer of values to and from this mesh using these
	void transfer_in(void);
	
	void transfer_out(bool setOutput = false);

	//AVERAGED INPUTS

	void transfer_in_averaged(void);

	//MULTIPLIED INPUTS

	//only use this if mesh_in2 was initialized as a vector of VEC<double> inputs : see corresponding Initialize_MeshTransfer_MultipliedInputs
	void transfer_in_multiplied(void);

	//DUPLICATED OUTPUTS

	void transfer_out_duplicated(bool setOutput = false);

	//flattened in and out transfer sizes (i.e. total number of cell contributions
	size_t size_transfer_in(void);
	size_t size_transfer_out(void);

	//this is used to pass transfer information to a cuVEC for copying to gpu memory : for gpu computations we use "flattened" transfers so it can be parallelized better
	//return type: vector of transfers, where INT3 contains : i - input mesh index, j - input mesh cell index, k - super-mesh cell index. the double entry is the weight for the value contribution
	std::vector<std::pair<INT3, double>> get_flattened_transfer_in_info(void);

	//this is used to pass transfer information to a cuVEC for copying to gpu memory : for gpu computations we use "flattened" transfers so it can be parallelized better
	//return type: vector of transfers, where INT3 contains : i - output mesh index, j - output mesh cell index, k - super-mesh cell index. the double entry is the weight for the value contribution
	std::vector<std::pair<INT3, double>> get_flattened_transfer_out_info(void);
};